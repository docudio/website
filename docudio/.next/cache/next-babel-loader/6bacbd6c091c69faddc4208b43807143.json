{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useSnackbar } from 'notistack';\nimport { removeSnackbar } from '../actions';\nvar displayed = [];\n\nvar Notifier = function Notifier() {\n  var dispatch = useDispatch();\n  var notifications = useSelector(function (store) {\n    return store.common.notifications || [];\n  });\n\n  var _useSnackbar = useSnackbar(),\n      enqueueSnackbar = _useSnackbar.enqueueSnackbar,\n      closeSnackbar = _useSnackbar.closeSnackbar;\n\n  var storeDisplayed = function storeDisplayed(id) {\n    displayed = [].concat(_toConsumableArray(displayed), [id]);\n  };\n\n  var removeDisplayed = function removeDisplayed(id) {\n    displayed = _toConsumableArray(displayed.filter(function (key) {\n      return id !== key;\n    }));\n  };\n\n  React.useEffect(function () {\n    notifications.forEach(function (_ref) {\n      var key = _ref.key,\n          message = _ref.message,\n          _ref$options = _ref.options,\n          options = _ref$options === void 0 ? {} : _ref$options,\n          _ref$dismissed = _ref.dismissed,\n          dismissed = _ref$dismissed === void 0 ? false : _ref$dismissed;\n\n      if (dismissed) {\n        // dismiss snackbar using notistack\n        closeSnackbar(key);\n        return;\n      } // do nothing if snackbar is already displayed\n\n\n      if (displayed.includes(key)) return; // display snackbar using notistack, cant pass a key when trying to prevent duplicates so gotta modify this.\n\n      if (options.preventDuplicate) {\n        enqueueSnackbar(message, _objectSpread(_objectSpread({}, options), {}, {\n          onClose: function onClose(event, reason, myKey) {\n            if (options.onClose) {\n              options.onClose(event, reason, myKey);\n            }\n          },\n          onExited: function onExited(event, myKey) {\n            // removen this snackbar from redux store\n            dispatch(removeSnackbar(myKey));\n            removeDisplayed(myKey);\n          }\n        }));\n      } else {\n        enqueueSnackbar(message, _objectSpread(_objectSpread({\n          key: key\n        }, options), {}, {\n          onClose: function onClose(event, reason, myKey) {\n            if (options.onClose) {\n              options.onClose(event, reason, myKey);\n            }\n          },\n          onExited: function onExited(event, myKey) {\n            // removen this snackbar from redux store\n            dispatch(removeSnackbar(myKey));\n            removeDisplayed(myKey);\n          }\n        }));\n      } // keep track of snackbars that we've displayed\n\n\n      storeDisplayed(key);\n    });\n  }, [notifications, closeSnackbar, enqueueSnackbar, dispatch]);\n  return null;\n};\n\nexport default Notifier;","map":null,"metadata":{},"sourceType":"module"}