{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nvar _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useSnackbar } from 'notistack';\nimport { removeSnackbar } from '../actions';\nvar displayed = [];\n\nvar Notifier = function Notifier() {\n  _s();\n\n  var dispatch = useDispatch();\n  var notifications = useSelector(function (store) {\n    return store.common.notifications || [];\n  });\n\n  var _useSnackbar = useSnackbar(),\n      enqueueSnackbar = _useSnackbar.enqueueSnackbar,\n      closeSnackbar = _useSnackbar.closeSnackbar;\n\n  var storeDisplayed = function storeDisplayed(id) {\n    displayed = [].concat(_toConsumableArray(displayed), [id]);\n  };\n\n  var removeDisplayed = function removeDisplayed(id) {\n    displayed = _toConsumableArray(displayed.filter(function (key) {\n      return id !== key;\n    }));\n  };\n\n  React.useEffect(function () {\n    notifications.forEach(function (_ref) {\n      var key = _ref.key,\n          message = _ref.message,\n          _ref$options = _ref.options,\n          options = _ref$options === void 0 ? {} : _ref$options,\n          _ref$dismissed = _ref.dismissed,\n          dismissed = _ref$dismissed === void 0 ? false : _ref$dismissed;\n\n      if (dismissed) {\n        // dismiss snackbar using notistack\n        closeSnackbar(key);\n        return;\n      } // do nothing if snackbar is already displayed\n\n\n      if (displayed.includes(key)) return; // display snackbar using notistack, cant pass a key when trying to prevent duplicates so gotta modify this.\n\n      if (options.preventDuplicate) {\n        enqueueSnackbar(message, _objectSpread(_objectSpread({}, options), {}, {\n          onClose: function onClose(event, reason, myKey) {\n            if (options.onClose) {\n              options.onClose(event, reason, myKey);\n            }\n          },\n          onExited: function onExited(event, myKey) {\n            // removen this snackbar from redux store\n            dispatch(removeSnackbar(myKey));\n            removeDisplayed(myKey);\n          }\n        }));\n      } else {\n        enqueueSnackbar(message, _objectSpread(_objectSpread({\n          key: key\n        }, options), {}, {\n          onClose: function onClose(event, reason, myKey) {\n            if (options.onClose) {\n              options.onClose(event, reason, myKey);\n            }\n          },\n          onExited: function onExited(event, myKey) {\n            // removen this snackbar from redux store\n            dispatch(removeSnackbar(myKey));\n            removeDisplayed(myKey);\n          }\n        }));\n      } // keep track of snackbars that we've displayed\n\n\n      storeDisplayed(key);\n    });\n  }, [notifications, closeSnackbar, enqueueSnackbar, dispatch]);\n  return null;\n};\n\n_s(Notifier, \"DN20G4yDJckP5AKSoyrZqMSOiqY=\", false, function () {\n  return [useDispatch, useSelector, useSnackbar];\n});\n\n_c = Notifier;\nexport default Notifier;\n\nvar _c;\n\n$RefreshReg$(_c, \"Notifier\");","map":{"version":3,"sources":["/Users/mkeffele/git_repos/website/docudio/utils/Notifier.js"],"names":["React","useDispatch","useSelector","useSnackbar","removeSnackbar","displayed","Notifier","dispatch","notifications","store","common","enqueueSnackbar","closeSnackbar","storeDisplayed","id","removeDisplayed","filter","key","useEffect","forEach","message","options","dismissed","includes","preventDuplicate","onClose","event","reason","myKey","onExited"],"mappings":"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","sourcesContent":["import React from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { useSnackbar } from 'notistack'\nimport { removeSnackbar } from '../actions'\n\nlet displayed = []\n\nconst Notifier = () => {\n  const dispatch = useDispatch()\n  const notifications = useSelector(store => store.common.notifications || [])\n  const { enqueueSnackbar, closeSnackbar } = useSnackbar()\n\n  const storeDisplayed = (id) => {\n    displayed = [...displayed, id]\n  }\n\n  const removeDisplayed = (id) => {\n    displayed = [...displayed.filter(key => id !== key)]\n  }\n\n  React.useEffect(() => {\n    notifications.forEach(({ key, message, options = {}, dismissed = false }) => {\n      if (dismissed) {\n        // dismiss snackbar using notistack\n        closeSnackbar(key)\n        return\n      }\n\n      // do nothing if snackbar is already displayed\n      if (displayed.includes(key)) return\n\n      // display snackbar using notistack, cant pass a key when trying to prevent duplicates so gotta modify this.\n      if (options.preventDuplicate) {\n        enqueueSnackbar(message, {\n\n          ...options,\n          onClose: (event, reason, myKey) => {\n            if (options.onClose) {\n              options.onClose(event, reason, myKey)\n            }\n          },\n          onExited: (event, myKey) => {\n          // removen this snackbar from redux store\n            dispatch(removeSnackbar(myKey))\n            removeDisplayed(myKey)\n          }\n        })\n      } else {\n        enqueueSnackbar(message, {\n          key,\n          ...options,\n          onClose: (event, reason, myKey) => {\n            if (options.onClose) {\n              options.onClose(event, reason, myKey)\n            }\n          },\n          onExited: (event, myKey) => {\n          // removen this snackbar from redux store\n            dispatch(removeSnackbar(myKey))\n            removeDisplayed(myKey)\n          }\n        })\n      }\n\n      // keep track of snackbars that we've displayed\n      storeDisplayed(key)\n    })\n  }, [notifications, closeSnackbar, enqueueSnackbar, dispatch])\n\n  return null\n}\n\nexport default Notifier\n"]},"metadata":{},"sourceType":"module"}